#!/bin/bash
source "$HOME/.local/share/dotfiles/bin/lib/helpers.sh"
set -e

log_header "Backup Files"

backup_dir="$HOME/backups"
timestamp=$(date +%Y%m%d_%H%M%S)
current_dir="$HOME"
selected_for_backup=()

if ! command -v fzf &>/dev/null; then
  log_error "fzf is not installed. Please install it to continue."
  exit 1
fi

if ! command -v pv &>/dev/null; then
  log_error "pv is not installed. Please install it for progress bars."
  exit 1
fi

mkdir -p "$backup_dir"

while true; do
  items=$(find "$current_dir" -mindepth 1 -maxdepth 1 \
    ! -path "$backup_dir" \
    ! -path "$HOME/.cache" \
    ! -path "$HOME/.claude" \
    ! -path "$HOME/.java" \
    ! -path "$HOME/.chromium" \
    ! -path "$HOME/.npm" \
    ! -path "$HOME/.oh-my-zsh" \
    ! -path "$HOME/.var" \
    ! -path "$HOME/.zsh_history" \
    ! -path "$HOME/.cargo" \
    2>/dev/null | sort)

  if [ "$current_dir" != "$HOME" ]; then
    items="[..]
$items"
  fi

  selection_info=""
  if [ ${#selected_for_backup[@]} -gt 0 ]; then
    selection_info=" (${#selected_for_backup[@]} selected)"
  fi

  header_text="enter: navigate, tab: select, ctrl-d: done, ctrl-c: cancel${selection_info}"
  term_width=$(tput cols)
  padding=$(( (term_width - ${#header_text}) / 2 ))
  centered_header=$(printf "%${padding}s%s" "" "$header_text")

  fzf_args=(
    --multi
    --header="$centered_header"
    --expect=ctrl-d
    --prompt="[$current_dir] > "
    --color 'pointer:green,marker:green'
  )

  result=$(echo "$items" | fzf "${fzf_args[@]}")
  exit_code=$?

  if [ $exit_code -eq 130 ]; then
    break
  fi

  key=$(echo "$result" | head -1)
  selection=$(echo "$result" | tail -n +2)

  if [ -z "$selection" ]; then
    continue
  fi

  if [ "$key" = "ctrl-d" ]; then
    while IFS= read -r item; do
      if [ "$item" != "[..]" ] && [ -n "$item" ]; then
        selected_for_backup+=("$item")
      fi
    done <<< "$selection"
    break
  fi

  item_count=$(echo "$selection" | wc -l)

  if [ $item_count -gt 1 ]; then
    while IFS= read -r item; do
      if [ "$item" != "[..]" ] && [ -n "$item" ]; then
        selected_for_backup+=("$item")
      fi
    done <<< "$selection"
    echo "Added $item_count items to backup list"
    sleep 0.5
  else
    if [ "$selection" = "[..]" ]; then
      current_dir=$(dirname "$current_dir")
    elif [ -d "$selection" ]; then
      current_dir="$selection"
    else
      selected_for_backup+=("$selection")
      echo "Added to backup list: $(basename "$selection")"
      sleep 0.5
    fi
  fi
done

if [ ${#selected_for_backup[@]} -eq 0 ]; then
  log_info "No items selected. Exiting."
  exit 0
fi

log_step "Starting backup of ${#selected_for_backup[@]} items..."

for full_path in "${selected_for_backup[@]}"; do
  if [ ! -e "$full_path" ]; then
    log_error "Warning: '$full_path' does not exist, skipping..."
    continue
  fi

  base_name=$(basename "$full_path")
  display_path=$(echo "$full_path" | sed "s|$HOME|~|")

  if [ -d "$full_path" ]; then
    backup_file="$backup_dir/${base_name}_${timestamp}.tar.gz"
    log_info "Backing up: $display_path"
    total_size=$(du -sb "$full_path" 2>/dev/null | awk '{print $1}')
    tar -cf - -C "$(dirname "$full_path")" "$(basename "$full_path")" |
      pv -pterb -s "$total_size" |
      gzip >"$backup_file"
    log_success "$display_path backed up"
    log_detail "$backup_file"
  else
    extension="${base_name##*.}"
    name="${base_name%.*}"

    if [ "$extension" = "$base_name" ]; then
      backup_file="$backup_dir/${base_name}_${timestamp}"
    else
      backup_file="$backup_dir/${name}_${timestamp}.${extension}"
    fi

    log_info "Backing up: $display_path"
    pv "$full_path" >"$backup_file"
    log_success "$display_path backed up"
    log_detail "$backup_file"
  fi

  echo ""
done

log_detail "Backup location: $backup_dir"
show_done
